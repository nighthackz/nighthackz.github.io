{
  "date" : 1129273200000,
  "title" : "Fault Containment: an unsung hero",
  "body" : "As I suffered through the <i>n</i><sup>th</sup> application crash\nof the day, I couldn't help thinking of my favorite\nunderappreciated Java feature: fault containment. Between\n<b>try{}catch</b> and the tight memory model, failures tend to\nhappen close to where the error is, and they can be caught with a\nvery good chance that there has been no corruption of neighbouring\ndata structures. So if you're using some sort of editor and one of\nthe commands has a bug in it, if it's written in Java you usually\nget a little pop-up box that says something like \"error in\ncommand\", and you can carry on working. In C apps, one bad pointer\nand you're blown out of the water, with all of your editing lost.\nThis is particularly bad in systems that use plugins where the\namount of QA is variable. A lot of what motivated the tight memory\nmodel was me having wasted too much of my life tracking down weird\nexotic memory smashes, and vowing to never have to waste time on\nstuff like that again.\n",
  "images" : [ {
    "image" : "AppCrash.gif",
    "href" : null,
    "align" : "right",
    "width" : 319,
    "height" : 292
  } ]
}