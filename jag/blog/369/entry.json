{
  "date" : 1306479600000,
  "title" : "ACE revisited",
  "body" : "Quite a few years ago I built a system called <a href=\n\"resource/ace.pdf\">ACE - the Algorithm Composition Engine</a>. It\nwas both a success and a failure that contains a pile of ideas that\nhave nagged me ever since. It was roughly a macro preprocessor like\nCPP, except that it delt in parse trees instead of characters. \n\n<p>Ace's equivalent of a macro was based on a pattern match in a\nparse tree rather than a token match in a characters stream. So one\ncould write:</p>\n<pre>\n$replace $0*2; $with $0&lt;&lt;1;\n</pre>\nThe most powerful function in ACE was <tt>$tradeoff(a,b)</tt> which\ntook as parameters two code fragments that were assumed to perform\nthe same computation. Tradeoff would compute time and space\nestimates for each code fragment, then choose one or the other\nbased on the probability of reaching that point. ACE was fed branch\nprobabilities and loop lap-counts to compute an expected execution\ncount for each point in the program. For tradeoff, if one code\nfragment was large and slow, and the other was small and fast, the\nchoice is clear. More commonly one is large and fast, the other is\nsmall and slow. If the expected execution count was low, the small\nand slow version would be picked, otherwise the large and fast\nversion would be picked. ACE essentially had a dial that let the\ndeveloper say \"give me the fastest version of this function that\nfit in N bytes\". \n\n<p>The parameters to tradeoff were usually based on different <a\nhref=\n\"entry/refactoring_considered_harmful_sometimes.html\">performance\nmotivated refactorings.</a> These could usually be done cleanly\nusing ACE, as described in <a href=\"resource/ace.pdf\">the\npaper</a>.</p>\n\n<p>ACE was very successful in that it made it possible for us to\nwrite simple clean code for high performance algorithms that was\nrobust and flexible. The downside was that very few developers\ncould figure out how to use it. It was a very different way to\nthink about coding. I came to think of ACE as a complete failure\nwhen I visited the group again to answer some questions about old\npieces of code and I discovered that instead of fixing problems in\nthe input to ACE, they had taken the output from ACE (which was\njust plain C code) and checked it into the source repository,\nthrowing away the preprocessor and it's input files.</p>\n\n<p>In later years I wrote yet another rule engine as a part of what\nbecame the Jackpot plugin for NetBeans. It's syntax was a little\nmore humane and a lot more powerful:</p>\n<pre>\n$a/2 =&gt; $a&gt;&gt;1 :  $a instanceof int &amp;&amp; $a&gt;=0\n</pre>\nRead \"=&gt;\" as \"becomes\" and \":\" as \"where\". The \"where\" clause\nallowed boolean predicates based on type and value inferencing. The\npredicates used a three state logic: true/false/maybe. For every\npoint in a program Jackpot maintained a set of\nthings-known-to-be-true. This most commonly came from <b>if</b>\nstatements. Following <tt>if(b)</tt> b was known-to-be-true in the\n<b>then</b> clause, and !b was known-to-be-true in the <b>else</b>\nclause. It wasn't good enough for anyone in the theorem-proving\ncommunity to find respectable, but it was good enough to be\nremarkably useful (I'm a huge fan of \"good enough\"). \n\n<p>The parser in both ACE and Jackpot was somewhat lenient.\nParticularly in ACE, this was used in a manner similar to how\nclosures are used in languages like Scala and Ruby to create what\nlook like new statements. But they were much more powerful because\nit was possible to introspect on the body in a very detailed way.\nWriting a set of transformation rules that would construct a <a\nhref=\"entry/equations_and_methods.html\">Newton's-method\nfunction</a> from an equation was possible in ACE.</p>\n\n<p>Food for thought.</p>\n\n<p><b>Update:</b> One reader commented:</p>\n\n<blockquote>\n  These map precisely to Scala pattern-match expressions: $replace\n  $0*2; $with $0&lt;&lt;1; could look like: case Mul(a,Num(2))\n  =&gt; LeftShift(a, 1) and $a/2 =&gt; $a&gt;&gt;1 : $a instanceof\n  int &amp;&amp; $a&gt;=0 would be case Div(a,2) if\n  a.isInstanceOf[Int] &amp;&amp; a &gt;= 0 except that it seems\n  like the predicate in ACE could be evaluated lazily on a\n  per-execution basis if I understand correctly.\n</blockquote>This is roughly correct, but the \"could be evaluated\nlazily\" point is crucial. The really hard part in these systems is\ngetting them to perform. Jackpot would take thousands of rules and\ncompile them down to optimized inline code that was extremely fast.\nTo understand how this worked, read up on database query\noptimization and the constructive equivalence of deterministic and\nnon-deterministic finite state automata. In jackpot the rule\nmatcher's performance was (almost) independent of the number of\nrules or their complexity. Applying thousands of rules to millions\nof lines of code worked remarkably well. \n\n<p>Also, both exploited algebraic transformations in matching. For\nexample, !(a&lt;b) was matched by the same patterns as a&gt;=b</p>\n\n",
  "images" : [ ]
}