{
  "date" : 1066114800000,
  "title" : "Is it ever too early to optimize?",
  "body" : "One of the general principles that is commonly followed is avoiding\npremature optimization. In general, I agree with this, although I\nfind it personally difficult: I learned to progam on a machine with\nonly 4K of RAM. These days, with RAM at $200/Gigabyte and multi-GHz\nmachines, we have the luxury of giving priority to issues like\ncleanliness, modularity and development time. On the whole, this is\nwonderful. But all too often I see this taken to an unhealthy\nextreme and slow bloated software results.\n\n<p>In the \"no premature optimization\" model of the world, you\nignore performance and build your system as cleanly as possible.\nThen you measure and tune. But after the tuning is done you can\nstill find that the system is slow, but there's no real performance\nproblem that you can localize. It's just a generalized, diffused\nslowness. A lot of small things spread everywhere that add up. One\nof the common categories is things that lead to a lot of wasted\nmemory traffic. For example, if you're doing a lot of text\ngeneration it's often easy to write code that uses string\nconcatenation a lot. I've seen code that uses <tt>String+</tt>char=\nall over the place. This does a huge amount of copying and is much\nless efficient than using StringBuffer. If you're doing heavy text\ngeneration, consider designing APIs that append to StringBuffer\nparameters, rather than returning Strings.</p>\n\n<p>Another thorny area is data structure design. Whenever possible,\nsystems should be designed so that as much as possible of the data\nstructures is encapsulated. A great example of this is the\ncontainer classes. There are many different kinds of containers\nwith different performance characteristics but which all implement\nthe Map interface. If your application uses the Map interface to\ndeclare all containers, then the constructor invocations can be\nchanged the accomodate different performance demands.</p>\n\n<p>But this breaks down in applications where there is some data\nstructure that pervades everything. For example, if you were\nbuilding an editor for 3D models, almost all parts of the\napplication interact with the model data structure. You can do a\nlot to hide the details, but there's only so much you can hide. If\nyou don't think hard about the data structure right at the\nbeginning of building the application, you're likely to end up with\nbig problems. In this situation, a \"clean\" design might involve\nrepresenting points as objects, and meshes as arrays of points. But\nwhen the meshes get very large, this breaks down. A better\nperforming representation would be one or more arrays of floating\npoint values and <i>no</i> explicit point object.</p>\n\n<p>It's all a matter of balance and forethought.</p>\n\n",
  "images" : [ ]
}