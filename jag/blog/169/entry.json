{
  "date" : 1143100800000,
  "title" : "Scripting flamewar",
  "body" : "I made some comments recently about scripting languages that\ngenerated flame storms in a variety of places. For example, <a\nhref=\"http://jdj.com\">JDJ</a> and <a href=\n\"http://www.artima.com/forums/flat.jsp?forum=270&amp;thread=151886\">Artima</a>.\nYes, I did say those things. But there's a lot of context missing,\nand they're the flippant soundbite version of what should have been\na long and careful explanation that could easily mushroom into a\nseries of PhD theses. Amongst all the flamage there are all kinds\nof generalizations about \"scripting languages\" versus \"compiled\nlanguages\". My big problem with a lot of it is simply that these\ntwo polarizing categories are a pretty poor way of capturing the\ndistinctions between language designs. The terms are almost as\ngoofy as \"Republican\" versus \"Democrat\". Taking huge\nmulti-dimensional spaces of choices on different issues, then\ncombining and simplifying them all down to a brutally simple binary\nchoice is goofy. \n\n<p>Over the years I've built quite a lot of scripting systems. I've\nalso built a number of compilers for non-scripting languages. Given\nenough beer I'll even admit to having implemented a Cobol compiler\nfor money in the deep dark past. But I've done more scripting\nsystems than non-scripting systems.</p>\n\n<p>There are issues in the tradeoffs between the two linguistic\nspaces all over the place. Someday I'd like to write a long tour\nthrough them, but there just aren't enough hours in a day. I have a\nhard time getting enough time to do even trivial blogging: being\ntruly thoughtful takes a lot of time. But I'll try to cover a\nfew.... For now, I'll make the generalization that \"scripting\nlanguage\" means one that is interpreted with dynamic runtime\ntyping, and the other camp is languages that are compiled to\nmachine code and have static runtime typing. This is a broad\nover-simplifying generalization, but it matches pretty well what\ngoes on in common conversations.</p>\n\n<p><b>Raw execution performance:</b> One of the usual arguments for\nscripting languages having acceptable performance is that the\noverhead of interpretation and dynamic typing doesn't matter. The\nperformance of the system is dominated by other factors: typically\nIO and the language primitives. For example, PERL apps usually\nspend the majority of their time in file IO and string primitives.\nI've strongly made this argument in the past, and it's quite valid.\nBut having observed developers usage patterns, the two most common\nthings that happen to erode the argument are:</p>\n\n<ol>\n  <li>Developers start doing things that are outside of what the\n  language primitives are good at. For example, PostScript has\n  great primitives for rendering. So long as you're doing\n  rendering, it flies like the wind. But then someone goes and\n  writes a game that's heavily based on rendering, and a piece of\n  it needs to do collision detection between missiles and targets.\n  Physics in PostScript: a bad idea.</li>\n\n  <li>Developers start clamoring for new primitives. Some are too\n  specialized to be reasonable \"I want a fast collision engine\",\n  some are rational \"object oriented programming has become the\n  dominant style in PostScript, but the OO model is implemented in\n  PostScript as a library and is slow\".</li>\n</ol>There are a bunch of ways to respond: \n\n<ol>\n  <li>\"Buzz off\". My personal favorite. Don't use a hammer to\n  tighten a bolt.</li>\n\n  <li>Start adding more primitives. This is hopeless: you drown in\n  wave after wave of requests.</li>\n\n  <li>Put in a facility for developers to write their own\n  primitives. eg. link hunks of C code into the interpreter. Can\n  work pretty well, but the linguistic universe schism can be\n  problematic. Not only do developers then need to learn two\n  environments, but because of the cross-language calls each\n  language can impose difficulties on the other (eg. doing a\n  language with a good garbage collector has a hard time\n  interacting well with C's malloc/free regime.</li>\n\n  <li>Make the \"scripting language\" fast enough to implement\n  primitives. It tends to end up not looking much like a scripting\n  language. This is roughly the road I went down with Java: to see\n  how close to a scripting experience I could get while being able\n  compile obvious statements like \"a=b+c\" into one instruction in\n  the common case. I could have gone down the road of making\n  declarations optional, but I intentionally didn't.</li>\n</ol><b>Worrying about scale, evolution and testing:</b> strong\ncompile-time types dramatically improve the ability of the tools\n(compiler, IDE, ...) to do global checking and manipulation. Some\npeople like this. Some don't. There's a fair amount of evidence\nthat these sorts of facilities are really helpful in dealing with\nsystems that get large, evolve over a long time or require large\nteams. The most-often-cited reason for preferring dynamic typing is\nthat it can make the development process easier: no need to bother\ntyping all those yucky declarations. \n\n<p>There are a variety of middle-ground solutions:</p>\n\n<ul>\n  <li>One is to allow, but not require, declarations. This is\n  particularly common in Lisp dialects where you can sprinkle\n  declarations like <tt>(fixnum i j k)</tt> where needed to cause\n  the code generators to generate efficient code. The big problem\n  is figuring out the \"where needed\" bit. Sometimes it can be dicey\n  to figure out all the places where there are issues. Often there\n  are no real performance hotspots: no loops burning up all the\n  time. Rather, it's a \"peanut butter\" problem where it's spread\n  everywhere: you have to tune <i>everything</i> to make a\n  difference.</li>\n\n  <li>\n    Another is to make the language be strongly/statically typed,\n    but to make the declaration process more transparent. One\n    extreme point in this space is <b>ML</b> which does extensive\n    type inferencing (leading sometimes to developer confusion\n    because they can't figure out what the type inferencing engine\n    is doing). An operator that I've long wanted to add to Java is\n    \"declare and assign\": \n\n    <table>\n      <tr>\n        <td valign=\"top\" nowrap>v:=e</td>\n\n        <td>Declares v to have the same type as e, and assigns e to\n        v. \"x:=r*sin(t);\" would be roughly equivalent to \"double x\n        = r*sin(t)\".</td>\n      </tr>\n\n      <tr>\n        <td valign=\"top\" nowrap>v:==e</td>\n\n        <td>Just like :=, except that it makes v final</td>\n      </tr>\n    </table>\n\n    <p>There's a lot more to say, but this is enough for\n    today...</p>\n  </li>\n</ul>\n",
  "images" : [ ]
}